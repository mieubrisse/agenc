{"id":"agent-egn","title":"Add postUpdateHook to repo config for library clone setup","description":"Add a per-repo postUpdateHook field to RepoConfig that the daemon executes in the repo library clone after each successful git pull. This allows repos to define setup commands (make setup, npm install, etc.) that run automatically, so mission clones created via rsync inherit a fully-configured working tree.\n\n## Motivation\n\nGit hooks (core.hooksPath), dependency caches (node_modules, go build cache), and other local config are not preserved across git clone. The repo library copy (~/.agenc/repos/\u003crepo\u003e) is the template that gets rsync'd into every new mission. If setup commands run in the library copy after each pull, every mission inherits the result for free — no per-mission setup needed.\n\nThe immediate use case is agent-r4i (pre-commit hook): 'make setup' sets core.hooksPath in the library copy, and rsync carries it into missions. But this generalizes to any repo that needs post-pull setup: dependency installs, code generation, build cache warming, etc.\n\n## Design\n\n### Config schema\n\nAdd a PostUpdateHook field to RepoConfig (internal/config/agenc_config.go):\n\n```yaml\nrepoConfig:\n  github.com/owner/repo:\n    alwaysSynced: true\n    postUpdateHook: \"make setup\"\n```\n\nThe field is a single string (shell command) executed via 'sh -c' in the repo library directory. It runs after a successful ForceUpdateRepo. If the command fails, log the error but do not block the update cycle — the repo is still updated, just not fully set up.\n\n### Execution point\n\nIn the daemon's repo update cycle (internal/server/template_updater.go), after ForceUpdateRepo succeeds in updateRepo(), check if the repo has a postUpdateHook configured. If so, execute it:\n\n```go\nfunc (s *Server) updateRepo(ctx context.Context, repoName string, refreshDefaultBranch bool) {\n    repoDirpath := config.GetRepoDirpath(s.agencDirpath, repoName)\n\n    // ... existing refreshDefaultBranch logic ...\n\n    if err := mission.ForceUpdateRepo(repoDirpath); err != nil {\n        s.logger.Printf(\"Repo update: failed to update '%s': %v\", repoName, err)\n        return  // \u003c-- return early, don't run hook on failed update\n    }\n\n    // Run postUpdateHook if configured\n    s.runPostUpdateHook(ctx, repoName, repoDirpath)\n}\n```\n\nThe new runPostUpdateHook method:\n- Reads the agenc config to get the RepoConfig for repoName\n- If PostUpdateHook is empty, returns immediately\n- Otherwise, runs the hook via exec.CommandContext(ctx, \"sh\", \"-c\", hook) with Dir set to repoDirpath\n- Logs stdout/stderr on failure\n- Does NOT fail the update cycle — just logs and continues\n\n### Optimization: only run on actual changes\n\nForceUpdateRepo does 'git fetch' then 'git reset --hard origin/\u003cbranch\u003e'. To avoid running the hook on every 60-second cycle when nothing changed, compare the HEAD commit before and after the update. Only run the hook if HEAD actually moved.\n\nThis requires a small change: capture HEAD before ForceUpdateRepo, compare after, and only call runPostUpdateHook if they differ. Use 'git rev-parse HEAD' for the comparison.\n\n```go\nfunc (s *Server) updateRepo(ctx context.Context, repoName string, refreshDefaultBranch bool) {\n    repoDirpath := config.GetRepoDirpath(s.agencDirpath, repoName)\n\n    // ... existing refreshDefaultBranch logic ...\n\n    // Capture HEAD before update\n    headBefore := getHEAD(repoDirpath)\n\n    if err := mission.ForceUpdateRepo(repoDirpath); err != nil {\n        s.logger.Printf(\"Repo update: failed to update '%s': %v\", repoName, err)\n        return\n    }\n\n    // Only run hook if HEAD actually changed\n    headAfter := getHEAD(repoDirpath)\n    if headBefore != headAfter {\n        s.runPostUpdateHook(ctx, repoName, repoDirpath)\n    }\n}\n```\n\n### Push-event path\n\nThe push-event handler (internal/server/repos.go) also calls ForceUpdateRepo when an agent pushes. Apply the same hook-after-update logic there: after ForceUpdateRepo succeeds, run the postUpdateHook if configured and if HEAD changed.\n\n### CLI: config set/get support\n\nThe existing 'agenc config repoConfig set' command (cmd/config_repo_config_set.go) needs a new --post-update-hook flag:\n\n    agenc config repoConfig set github.com/owner/repo --post-update-hook=\"make setup\"\n\nTo clear: agenc config repoConfig set github.com/owner/repo --post-update-hook=\"\"\n\n### First-run bootstrapping\n\nWhen a repo is first cloned (ensureRepoCloned in template_updater.go), also run the postUpdateHook after the clone completes. This ensures brand-new library clones get the full setup without waiting for the next update cycle.\n\n## Testing\n\n1. Unit test: RepoConfig serialization round-trip with PostUpdateHook field\n2. Unit test: runPostUpdateHook logs and continues on failure (does not panic or block)\n3. Integration: configure a postUpdateHook, trigger an update, verify the hook ran (e.g., check for a side effect like a file being created)\n4. Verify hook does NOT run when HEAD is unchanged (no-op pull cycle)\n5. Verify hook runs on first clone via ensureRepoCloned\n\n## Dependencies\n\nThis feature depends on agent-r4i (pre-commit hook / make setup) being implemented first — that provides the concrete 'make setup' command this hook would run. However, the feature is independently useful for any post-pull setup command.","status":"open","priority":2,"issue_type":"feature","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T18:29:17Z","created_by":"Kevin Today","updated_at":"2026-02-27T18:29:17Z","dependencies":[{"issue_id":"agent-egn","depends_on_id":"agent-r4i","type":"blocks","created_at":"2026-02-27T15:29:23Z","created_by":"Kevin Today","metadata":"{}"}]}
{"id":"agent-r4i","title":"Add git pre-commit hook and make setup/check targets","description":"Add a git pre-commit hook that enforces code quality checks (formatting, vetting, tests) on every commit. This replaces the current approach of relying on agents to voluntarily run 'make build'.\n\n## Context\n\nAgents working in this repo frequently skip quality checks before committing. The current CLAUDE.md tells them to use 'make build', but this is advisory — there is no enforcement. A git pre-commit hook provides structural enforcement that cannot be bypassed.\n\nThe library repo copy (in ~/.agenc/repos/) is rsync'd into mission directories via CopyRepo (internal/mission/repo.go:100). Since rsync copies .git/config, any local git config (like core.hooksPath) set in the library copy propagates to all mission clones automatically. This means setting up hooks in the library copy is sufficient — no per-mission setup needed.\n\n## Implementation Steps\n\n### Step 0: Fix pre-existing test failures\n\nTwo test suites currently fail. These MUST be fixed before the hook is added, otherwise no one can commit (including the commit that adds the hook).\n\n1. internal/claudeconfig/prime_content_test.go:40 — TestGetPrimeContent fails because prime_content.md doesn't contain \"agenc daemon\". The generated content is stale. Fix: run 'make genskill' to regenerate, then check if the test expectation or the generator needs updating. The \"agenc daemon\" command group may have been renamed or removed.\n\n2. internal/launchd/plist_test.go:211 — TestCronToPlistFilename fails because CronToPlistFilename() (plist.go:161) doesn't sanitize its input. It returns the cron name verbatim in the filename. The test expects spaces replaced with hyphens and special chars stripped. Fix: add sanitization to CronToPlistFilename() — replace spaces with hyphens, strip characters that aren't alphanumeric/hyphen/underscore.\n\n### Step 1: Create 'make check' target\n\nAdd a 'check' target to the Makefile that runs the quality gates WITHOUT binary compilation, genskill, or docs generation:\n\n```makefile\ncheck:\n\t@test -f internal/claudeconfig/prime_content.md || touch internal/claudeconfig/prime_content.md\n\t@echo \"Checking code formatting...\"\n\t@unformatted=$$(gofmt -l .); \\\n\tif [ -n \"$$unformatted\" ]; then \\\n\t\techo \"Files need formatting:\"; \\\n\t\techo \"$$unformatted\"; \\\n\t\techo \"\"; \\\n\t\techo \"Run: gofmt -w .\"; \\\n\t\texit 1; \\\n\tfi\n\t@echo \"Formatting OK\"\n\t@echo \"Running go vet...\"\n\t@go vet ./...\n\t@echo \"Static analysis OK\"\n\t@echo \"Running tests...\"\n\t@go test ./...\n\t@echo \"Tests passed\"\n```\n\nThe prime_content.md touch is needed because go vet/test will fail on a fresh checkout without the embed placeholder.\n\nThen refactor 'make build' to depend on 'check' instead of inlining the same steps:\n\n```makefile\nbuild: genskill docs setup check\n\t@echo \"Building agenc...\"\n\t@go build -ldflags \"$(LDFLAGS)\" -o agenc .\n\t@echo \"Build complete\"\n```\n\n### Step 2: Create 'make setup' target\n\n```makefile\nsetup:\n\t@if git rev-parse --git-dir \u003e/dev/null 2\u003e\u00261; then \\\n\t\tcurrent=$$(git config core.hooksPath 2\u003e/dev/null); \\\n\t\tif [ \"$$current\" != \".githooks\" ]; then \\\n\t\t\tgit config core.hooksPath .githooks; \\\n\t\t\techo \"Git hooks configured (.githooks/)\"; \\\n\t\tfi; \\\n\tfi\n```\n\nProperties: idempotent (no-op if already set), CI-safe (no-op if no .git), silent on repeat runs.\n\n'make build' depends on 'setup' so hooks auto-activate on first build.\n\n### Step 3: Create .githooks/pre-commit\n\nCreate .githooks/pre-commit (must be executable: chmod +x):\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\n# Run quality checks (formatting, vet, tests)\nmake check\n\n# Chain to beads pre-commit hook if bd is available\nif command -v bd \u003e/dev/null 2\u003e\u00261; then\n    bd hook pre-commit \"$@\"\nfi\n```\n\n### Step 4: Create shims for all other beads hooks\n\nSince core.hooksPath overrides .git/hooks/ entirely, we need shims in .githooks/ for ALL five beads hooks, not just pre-commit. The other four are pass-through shims.\n\nCreate these files (all chmod +x):\n\n.githooks/prepare-commit-msg:\n```bash\n#!/usr/bin/env bash\nif command -v bd \u003e/dev/null 2\u003e\u00261; then\n    exec bd hook prepare-commit-msg \"$@\"\nfi\n```\n\n.githooks/pre-push:\n```bash\n#!/usr/bin/env bash\nif command -v bd \u003e/dev/null 2\u003e\u00261; then\n    exec bd hook pre-push \"$@\"\nfi\n```\n\n.githooks/post-checkout:\n```bash\n#!/usr/bin/env bash\nif command -v bd \u003e/dev/null 2\u003e\u00261; then\n    exec bd hook post-checkout \"$@\"\nfi\n```\n\n.githooks/post-merge:\n```bash\n#!/usr/bin/env bash\nif command -v bd \u003e/dev/null 2\u003e\u00261; then\n    exec bd hook post-merge \"$@\"\nfi\n```\n\nNote: the beads hooks in .beads/hooks/ use two different shim versions (v1 uses 'bd hooks run', v2 uses 'bd hook'). Use the v2 pattern ('bd hook \u003cname\u003e') for all shims since it is the newer API.\n\n### Step 5: Update CLAUDE.md\n\nUpdate the \"Building the Binary\" section to document:\n- 'make setup' is run automatically by 'make build' on first invocation (sets up git hooks)\n- 'make check' runs formatting, vetting, and tests (no binary)\n- 'make build' runs check + compiles the binary (the canonical verification command)\n- The pre-commit hook runs 'make check' automatically on every git commit\n- Do NOT use --no-verify to skip hooks\n\n## Testing\n\nAfter implementation, verify:\n1. 'make check' passes independently\n2. 'make setup' is idempotent (run twice, second is silent)\n3. 'make build' runs setup + check + compile\n4. 'git commit' with a formatting error is rejected by the hook\n5. 'git commit' with passing code succeeds (and beads hook still runs)\n6. A fresh clone + 'make build' activates hooks automatically","status":"closed","priority":2,"issue_type":"feature","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T17:48:10Z","created_by":"Kevin Today","updated_at":"2026-02-27T17:56:21Z","closed_at":"2026-02-27T17:56:21Z","close_reason":"Implemented make setup/check targets and .githooks/ pre-commit hook with beads shims"}
{"id":"agent-xfm","title":"Investigate persistence for repo update requests","description":"When the daemon's centralized repo update worker receives update requests via channel (from cron ticker or push events), those requests are lost if the server dies before processing them. Currently, the cron ticker runs a full update cycle immediately on startup, which catches repos that are alwaysSynced or have active missions (heartbeat \u003c 5 min). This is likely sufficient, but there's a theoretical gap: if the server is down \u003e5 min, heartbeats go stale and repos with inactive missions won't get their pending updates. Investigate whether this gap matters in practice and whether explicit persistence (e.g., writing pending update requests to disk) is needed. Context: this arises from the postUpdateHook feature (agent-egn) which centralizes all force-pull operations into a single worker goroutine that processes channel-based requests.","status":"open","priority":4,"issue_type":"task","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T19:11:55Z","created_by":"Kevin Today","updated_at":"2026-02-27T19:11:55Z"}
{"id":"agent-1er","title":"Add sessions table and session scanner pipeline","description":"Build the core session scanner infrastructure: (1) new sessions table with migration (id, mission_id, custom_title, auto_summary, last_scanned_offset), (2) server-side polling loop (3s interval) that globs for JSONL files, incrementally scans from byte offsets, extracts custom-title and summary entries, and stores them in the DB, (3) server-side tmux rename when custom_title changes (read tmux_pane from missions table, apply guards, call tmux rename-window). See docs/plans/2026-02-27-session-scanner-pipeline-design.md","status":"open","priority":1,"issue_type":"feature","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T19:51:29Z","created_by":"Kevin Today","updated_at":"2026-02-27T19:51:29Z"}
{"id":"agent-asi","title":"Drop session_name from missions table and simplify wrapper","description":"Migration to drop session_name and session_name_updated_at columns from the missions table. Remove updateWindowTitleFromSession() from the wrapper. Remove session name DB writes from the Stop handler. Keep renameWindowForTmux() for initial window naming and keep color management. Depends on the session scanner pipeline being in place.","status":"open","priority":2,"issue_type":"task","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T19:51:37Z","created_by":"Kevin Today","updated_at":"2026-02-27T19:51:37Z","dependencies":[{"issue_id":"agent-asi","depends_on_id":"agent-1er","type":"blocks","created_at":"2026-02-27T16:51:54Z","created_by":"Kevin Today","metadata":"{}"}]}
{"id":"agent-ctr","title":"Tmux rename on mission switch","description":"When the user switches between missions in the same tmux window, rename the window to match the new mission's session name. This requires detecting mission switches (possibly via tmux_pane changes in the DB) and looking up the best available session name for the newly-active mission.","status":"open","priority":3,"issue_type":"feature","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T19:51:43Z","created_by":"Kevin Today","updated_at":"2026-02-27T19:51:43Z","dependencies":[{"issue_id":"agent-ctr","depends_on_id":"agent-1er","type":"blocks","created_at":"2026-02-27T16:51:58Z","created_by":"Kevin Today","metadata":"{}"}]}
{"id":"agent-u33","title":"Refactor AI summarizer to use session scanner pipeline","description":"The mission summarizer currently scans JSONL files independently via ExtractRecentUserMessages(). Refactor it to read from the sessions table populated by the session scanner, instead of re-scanning JSONL files. This eliminates duplicate JSONL scanning and lets the summarizer benefit from incremental indexing.","status":"open","priority":3,"issue_type":"task","owner":"1142185+mieubrisse@users.noreply.github.com","created_at":"2026-02-27T19:51:49Z","created_by":"Kevin Today","updated_at":"2026-02-27T19:51:49Z","dependencies":[{"issue_id":"agent-u33","depends_on_id":"agent-1er","type":"blocks","created_at":"2026-02-27T16:52:04Z","created_by":"Kevin Today","metadata":"{}"}]}
