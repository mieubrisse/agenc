package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/mieubrisse/stacktrace"
	"github.com/odyssey/agenc/internal/config"
	"github.com/spf13/cobra"
)

const (
	sentinelBegin = "# >>> AgenC keybindings >>>"
	sentinelEnd   = "# <<< AgenC keybindings <<<"
)

var tmuxInjectCmd = &cobra.Command{
	Use:   injectCmdStr,
	Short: "Install AgenC tmux keybindings",
	Long: `Write an AgenC-managed keybindings file and add a source-file directive to
your tmux.conf. If a tmux server is running, the keybindings are sourced
immediately.

All keybindings live under the "agenc" key table, activated with prefix + a:
  prefix + a, M  — new mission in a new tmux window
  prefix + a, P  — new mission in a side-by-side pane`,
	Args: cobra.NoArgs,
	RunE: runTmuxInject,
}

func init() {
	tmuxCmd.AddCommand(tmuxInjectCmd)
}

func runTmuxInject(cmd *cobra.Command, args []string) error {
	agencDirpath, err := config.GetAgencDirpath()
	if err != nil {
		return stacktrace.Propagate(err, "failed to resolve agenc directory")
	}

	keybindingsFilepath := config.GetTmuxKeybindingsFilepath(agencDirpath)

	if err := writeKeybindingsFile(keybindingsFilepath); err != nil {
		return err
	}
	fmt.Printf("Wrote keybindings to %s\n", keybindingsFilepath)

	// Use ~ in the source-file directive so tmux.conf is portable across machines
	displayFilepath := contractHomePath(keybindingsFilepath)

	if err := injectTmuxConfSourceLine(keybindingsFilepath, displayFilepath); err != nil {
		return err
	}

	sourceTmuxKeybindings(keybindingsFilepath)

	return nil
}

// contractHomePath replaces a leading $HOME prefix with ~ for use in
// config files that should be portable across machines.
func contractHomePath(path string) string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return path
	}
	if strings.HasPrefix(path, homeDir) {
		return "~" + path[len(homeDir):]
	}
	return path
}

// agencKeyTable is the tmux key table name used to namespace all AgenC
// keybindings behind a prefix (prefix + a → agenc table).
const agencKeyTable = "agenc"

// generateKeybindingsContent returns the full content of the agenc-managed
// tmux keybindings configuration file.
func generateKeybindingsContent() string {
	var sb strings.Builder

	sb.WriteString("# AgenC tmux keybindings\n")
	sb.WriteString("# Generated by: agenc tmux inject\n")
	sb.WriteString("# Do not edit — this file is overwritten on each run.\n")
	sb.WriteString("\n")

	// prefix + a enters the agenc key table
	sb.WriteString("# Enter the AgenC key table (prefix + a)\n")
	fmt.Fprintf(&sb, "bind-key a switch-client -T %s\n", agencKeyTable)
	sb.WriteString("\n")

	// agenc table: M — new mission in a new window
	sb.WriteString("# New mission in a new window (prefix + a, M)\n")
	fmt.Fprintf(&sb, "bind-key -T %s M run-shell '%s %s %s %s --parent-pane \"#{pane_id}\" -- %s %s %s'\n",
		agencKeyTable,
		agencCmdStr, tmuxCmdStr, windowCmdStr, newCmdStr,
		agencCmdStr, missionCmdStr, newCmdStr,
	)

	sb.WriteString("\n")

	// agenc table: P — new mission in a side-by-side pane
	sb.WriteString("# New mission in a side-by-side pane (prefix + a, P)\n")
	fmt.Fprintf(&sb, "bind-key -T %s P run-shell '%s %s %s %s --parent-pane \"#{pane_id}\" -- %s %s %s'\n",
		agencKeyTable,
		agencCmdStr, tmuxCmdStr, paneCmdStr, newCmdStr,
		agencCmdStr, missionCmdStr, newCmdStr,
	)

	return sb.String()
}

// writeKeybindingsFile writes the agenc-managed keybindings file, overwriting
// any previous version.
func writeKeybindingsFile(keybindingsFilepath string) error {
	content := generateKeybindingsContent()
	if err := os.WriteFile(keybindingsFilepath, []byte(content), 0644); err != nil {
		return stacktrace.Propagate(err, "failed to write keybindings file '%s'", keybindingsFilepath)
	}
	return nil
}

// findTmuxConfFilepath locates the user's tmux.conf. It checks ~/.tmux.conf
// first, then ~/.config/tmux/tmux.conf. Returns the path, whether the file
// currently exists, and any error.
func findTmuxConfFilepath() (string, bool, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", false, stacktrace.Propagate(err, "failed to determine home directory")
	}

	candidates := []string{
		filepath.Join(homeDir, ".tmux.conf"),
		filepath.Join(homeDir, ".config", "tmux", "tmux.conf"),
	}

	for _, candidate := range candidates {
		if _, err := os.Stat(candidate); err == nil {
			return candidate, true, nil
		}
	}

	// Neither exists — default to ~/.tmux.conf
	return candidates[0], false, nil
}

// buildSentinelBlock returns the sentinel-wrapped source-file directive.
// The path written into the directive uses displayFilepath (which may contain ~)
// so the resulting tmux.conf is portable across machines.
func buildSentinelBlock(displayFilepath string) string {
	return fmt.Sprintf("%s\nsource-file %s\n%s", sentinelBegin, displayFilepath, sentinelEnd)
}

// injectTmuxConfSourceLine idempotently adds or updates a sentinel-wrapped
// source-file directive in the user's tmux.conf. The keybindingsFilepath is
// the absolute path used for file I/O; displayFilepath is the portable form
// (with ~ instead of $HOME) written into the directive.
func injectTmuxConfSourceLine(keybindingsFilepath string, displayFilepath string) error {
	tmuxConfFilepath, exists, err := findTmuxConfFilepath()
	if err != nil {
		return err
	}

	sentinelBlock := buildSentinelBlock(displayFilepath)

	if !exists {
		// Create the file with just the sentinel block
		if err := os.WriteFile(tmuxConfFilepath, []byte(sentinelBlock+"\n"), 0644); err != nil {
			return stacktrace.Propagate(err, "failed to create '%s'", tmuxConfFilepath)
		}
		fmt.Printf("Created %s with source-file directive\n", tmuxConfFilepath)
		return nil
	}

	content, err := os.ReadFile(tmuxConfFilepath)
	if err != nil {
		return stacktrace.Propagate(err, "failed to read '%s'", tmuxConfFilepath)
	}
	fileContent := string(content)

	beginIdx := strings.Index(fileContent, sentinelBegin)
	endIdx := strings.Index(fileContent, sentinelEnd)

	if beginIdx >= 0 && endIdx >= 0 {
		// Sentinel block exists — check if it's identical
		existingBlock := fileContent[beginIdx : endIdx+len(sentinelEnd)]
		if existingBlock == sentinelBlock {
			fmt.Printf("Already configured in %s\n", tmuxConfFilepath)
			return nil
		}

		// Different path — replace the block
		newContent := fileContent[:beginIdx] + sentinelBlock + fileContent[endIdx+len(sentinelEnd):]
		if err := os.WriteFile(tmuxConfFilepath, []byte(newContent), 0644); err != nil {
			return stacktrace.Propagate(err, "failed to update '%s'", tmuxConfFilepath)
		}
		fmt.Printf("Updated source-file directive in %s\n", tmuxConfFilepath)
		return nil
	}

	// No sentinel block — append to file
	appendContent := fileContent
	if !strings.HasSuffix(appendContent, "\n") {
		appendContent += "\n"
	}
	appendContent += "\n" + sentinelBlock + "\n"

	if err := os.WriteFile(tmuxConfFilepath, []byte(appendContent), 0644); err != nil {
		return stacktrace.Propagate(err, "failed to update '%s'", tmuxConfFilepath)
	}
	fmt.Printf("Added source-file directive to %s\n", tmuxConfFilepath)
	return nil
}

// sourceTmuxKeybindings sources the keybindings file into a running tmux
// server if one exists. Prints a skip message otherwise.
func sourceTmuxKeybindings(keybindingsFilepath string) {
	// Check if tmux server is running by listing sessions
	if err := exec.Command("tmux", "list-sessions").Run(); err != nil {
		fmt.Println("No running tmux server detected — keybindings will take effect on next tmux start")
		return
	}

	sourceCmd := exec.Command("tmux", "source-file", keybindingsFilepath)
	if err := sourceCmd.Run(); err != nil {
		fmt.Printf("Warning: failed to source keybindings into running tmux server: %v\n", err)
		return
	}

	fmt.Println("Sourced keybindings into running tmux server")
}
