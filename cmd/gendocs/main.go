package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"

	"github.com/odyssey/agenc/cmd"
)

func main() {
	outputFilepath := "./docs/cli.md"
	if len(os.Args) > 1 {
		outputFilepath = os.Args[1]
	}

	if err := os.MkdirAll(filepath.Dir(outputFilepath), 0755); err != nil {
		log.Fatalf("failed to create output directory: %v", err)
	}

	rootCmd := cmd.GetRootCmd()

	var buf bytes.Buffer
	buf.WriteString("# CLI Reference\n\n")
	buf.WriteString("Auto-generated documentation for all agenc commands.\n\n")
	buf.WriteString("---\n\n")

	if err := generateCommandDocs(&buf, rootCmd, 0); err != nil {
		log.Fatalf("failed to generate docs: %v", err)
	}

	if err := os.WriteFile(outputFilepath, buf.Bytes(), 0644); err != nil {
		log.Fatalf("failed to write docs file: %v", err)
	}

	log.Printf("Documentation generated: %s", outputFilepath)
}

func generateCommandDocs(buf *bytes.Buffer, cmd *cobra.Command, depth int) error {
	// Generate markdown for this command
	var cmdBuf bytes.Buffer
	if err := doc.GenMarkdown(cmd, &cmdBuf); err != nil {
		return fmt.Errorf("failed to generate markdown for %s: %w", cmd.CommandPath(), err)
	}

	// Process the generated markdown:
	// - Adjust heading levels based on depth
	// - Remove the auto-generated footer
	content := cmdBuf.String()
	content = adjustHeadings(content, depth)
	content = removeAutoGenFooter(content)
	content = removeInternalLinks(content)

	buf.WriteString(content)
	buf.WriteString("\n---\n\n")

	// Sort subcommands alphabetically for consistent output
	subcommands := cmd.Commands()
	sort.Slice(subcommands, func(i, j int) bool {
		return subcommands[i].Name() < subcommands[j].Name()
	})

	// Recurse into subcommands
	for _, subcmd := range subcommands {
		if !subcmd.IsAvailableCommand() || subcmd.IsAdditionalHelpTopicCommand() {
			continue
		}
		if err := generateCommandDocs(buf, subcmd, depth+1); err != nil {
			return err
		}
	}

	return nil
}

func adjustHeadings(content string, depth int) string {
	// The generated markdown uses ## for the command name
	// Adjust based on depth so nested commands have deeper headings
	lines := strings.Split(content, "\n")
	var result []string

	for _, line := range lines {
		if strings.HasPrefix(line, "## ") {
			// Main command heading - adjust based on depth
			prefix := strings.Repeat("#", depth+2)
			line = prefix + line[2:]
		} else if strings.HasPrefix(line, "### ") {
			// Subheadings (Options, SEE ALSO, etc.) - adjust based on depth
			prefix := strings.Repeat("#", depth+3)
			line = prefix + line[3:]
		}
		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

func removeAutoGenFooter(content string) string {
	// Remove the "Auto generated by spf13/cobra" line
	lines := strings.Split(content, "\n")
	var result []string

	for _, line := range lines {
		if strings.Contains(line, "Auto generated by spf13/cobra") {
			continue
		}
		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

func removeInternalLinks(content string) string {
	// Remove markdown links to other command files since we're in a single file
	// Convert "* [agenc foo](agenc_foo.md)	 - description" to "* agenc foo - description"
	lines := strings.Split(content, "\n")
	var result []string

	for _, line := range lines {
		// Match pattern: * [command name](filename.md) with optional description
		if strings.HasPrefix(line, "* [") && strings.Contains(line, "](") && strings.Contains(line, ".md)") {
			// Extract the command name from the link text
			start := strings.Index(line, "[") + 1
			end := strings.Index(line, "]")
			if start > 0 && end > start {
				cmdName := line[start:end]
				// Extract description if present (after the closing paren)
				desc := ""
				parenIdx := strings.Index(line, ".md)")
				if parenIdx != -1 {
					afterParen := line[parenIdx+4:]
					// Clean up the tab separator
					desc = strings.TrimPrefix(afterParen, "\t")
					if desc != "" {
						desc = " " + desc
					}
				}
				line = "* " + cmdName + desc
			}
		}
		result = append(result, line)
	}

	return strings.Join(result, "\n")
}
