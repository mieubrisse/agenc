package history

import (
	"bufio"
	"encoding/json"
	"os"
	"strings"
)

// historyEntry represents a single line in Claude's history.jsonl file.
type historyEntry struct {
	Display string `json:"display"`
	Project string `json:"project"`
}

// FindFirstPrompt scans historyFilepath for the first line whose project path
// contains the given missionID. Returns the display text of that entry, or ""
// if no match is found or the file cannot be read.
//
// Skips command-only entries (e.g., "/login ", "/help ") which are generated
// when Claude Code processes slash commands. These entries are not meaningful
// session descriptions.
func FindFirstPrompt(historyFilepath string, missionID string) string {
	file, err := os.Open(historyFilepath)
	if err != nil {
		return ""
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.Contains(line, missionID) {
			continue
		}

		var entry historyEntry
		if err := json.Unmarshal([]byte(line), &entry); err != nil {
			continue
		}

		// Verify the UUID appears in the project path, not just in the display text
		if !strings.Contains(entry.Project, missionID) {
			continue
		}

		// Skip command-only entries (slash command followed by optional space)
		display := strings.TrimSpace(entry.Display)
		if isCommandOnlyEntry(display) {
			continue
		}

		return entry.Display
	}

	return ""
}

// isCommandOnlyEntry returns true if the text looks like a command-only history
// entry (e.g., "/login", "/help", "/commit"). These are generated by Claude Code
// when processing slash commands and should not be used as session names.
func isCommandOnlyEntry(text string) bool {
	if !strings.HasPrefix(text, "/") {
		return false
	}

	// Command-only entries are short (just the command name, no arguments or description)
	// and typically match the pattern: /command-name
	if len(text) > 30 {
		return false
	}

	// Check if it's just a slash command with no meaningful content after it
	// Examples: "/login", "/help", "/commit", etc.
	// Not examples: "/login to configure auth", "/help me with..."
	parts := strings.Fields(text)
	if len(parts) != 1 {
		return false
	}

	// The single part should start with / and contain only word characters
	return strings.HasPrefix(parts[0], "/") && len(parts[0]) > 1
}
