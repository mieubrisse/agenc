package tmux

import (
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/mieubrisse/stacktrace"

	"github.com/odyssey/agenc/internal/config"
)

// agencKeyTable is the tmux key table name used to namespace all AgenC
// keybindings behind a prefix (prefix + a → agenc table).
const agencKeyTable = "agenc"

// CustomKeybinding represents a user/builtin keybinding to emit in the
// generated tmux keybindings file.
type CustomKeybinding struct {
	Key             string // tmux key (e.g. "f", "C-y")
	Command         string // full command string (already substituted with agenc binary)
	Comment         string // human-readable comment for the generated file
	IsMissionScoped bool   // true if the command requires a focused mission pane
}

// GenerateKeybindingsContent returns the full content of the agenc-managed
// tmux keybindings configuration file. The tmuxMajor/tmuxMinor parameters
// control version-gated features (e.g. display-popup requires tmux >= 3.2).
// The agencBinary parameter is the binary name or path used in the palette
// keybinding. The paletteKey parameter is the tmux key for the command palette
// (e.g. "k"). The customKeybindings slice contains all keybindings from
// resolved palette commands (both builtin and user-defined).
func GenerateKeybindingsContent(tmuxMajor, tmuxMinor int, agencBinary string, paletteKey string, customKeybindings []CustomKeybinding) string {
	var sb strings.Builder

	sb.WriteString("# AgenC tmux keybindings\n")
	sb.WriteString("# Generated by: agenc tmux inject\n")
	sb.WriteString("# Do not edit — this file is overwritten on each run.\n")
	sb.WriteString("\n")

	// prefix + a enters the agenc key table
	sb.WriteString("# Enter the AgenC key table (prefix + a)\n")
	fmt.Fprintf(&sb, "bind-key a switch-client -T %s\n", agencKeyTable)

	// Command palette (requires tmux >= 3.2 for display-popup).
	// Always resolves the focused mission UUID so the palette can filter
	// mission-scoped commands and pass the UUID into executed commands.
	// #{pane_id} is expanded by tmux at key-press time to the active pane.
	if tmuxMajor > 3 || (tmuxMajor == 3 && tmuxMinor >= 2) {
		sb.WriteString("\n")
		fmt.Fprintf(&sb, "# Command palette (prefix + a, %s)\n", paletteKey)
		fmt.Fprintf(&sb, "bind-key -T %s %s run-shell '"+
			"AGENC_CALLING_MISSION_UUID=$(%s tmux resolve-mission \"#{pane_id}\"); "+
			"tmux display-popup -E -w 60%% -h 50%% "+
			"\"AGENC_CALLING_MISSION_UUID=$AGENC_CALLING_MISSION_UUID %s tmux palette\""+
			"'\n", agencKeyTable, paletteKey, agencBinary, agencBinary)
	}

	// Emit all keybindings from resolved palette commands
	for _, kb := range customKeybindings {
		sb.WriteString("\n")
		if kb.Comment != "" {
			fmt.Fprintf(&sb, "# %s\n", kb.Comment)
		}
		if kb.IsMissionScoped {
			// Mission-scoped: resolve the pane's mission UUID first, skip if empty.
			// #{pane_id} is expanded by tmux at key-press time.
			fmt.Fprintf(&sb, "bind-key -T %s %s run-shell '"+
				"AGENC_CALLING_MISSION_UUID=$(%s tmux resolve-mission \"#{pane_id}\"); "+
				"[ -n \"$AGENC_CALLING_MISSION_UUID\" ] && %s"+
				"'\n", agencKeyTable, kb.Key, agencBinary, kb.Command)
		} else {
			fmt.Fprintf(&sb, "bind-key -T %s %s run-shell '%s'\n", agencKeyTable, kb.Key, kb.Command)
		}
	}

	return sb.String()
}

// WriteKeybindingsFile writes the agenc-managed keybindings file, overwriting
// any previous version. The tmuxMajor/tmuxMinor parameters control
// version-gated keybindings. The agencBinary parameter is the binary name or
// path used in run-shell commands. The paletteKey parameter is the tmux key
// for the command palette.
func WriteKeybindingsFile(keybindingsFilepath string, tmuxMajor, tmuxMinor int, agencBinary string, paletteKey string, customKeybindings []CustomKeybinding) error {
	content := GenerateKeybindingsContent(tmuxMajor, tmuxMinor, agencBinary, paletteKey, customKeybindings)
	if err := os.WriteFile(keybindingsFilepath, []byte(content), 0644); err != nil {
		return stacktrace.Propagate(err, "failed to write keybindings file '%s'", keybindingsFilepath)
	}
	return nil
}

// BuildKeybindingsFromCommands converts resolved palette commands into
// CustomKeybinding entries for keybinding generation. This is the single
// source of truth used by both `agenc tmux inject` and the daemon's
// keybindings writer loop.
func BuildKeybindingsFromCommands(resolved []config.ResolvedPaletteCommand) []CustomKeybinding {
	var keybindings []CustomKeybinding
	for _, cmd := range resolved {
		if cmd.TmuxKeybinding == "" {
			continue
		}
		comment := fmt.Sprintf("%s (prefix + a, %s)", cmd.Name, cmd.TmuxKeybinding)
		if cmd.Title != "" {
			comment = fmt.Sprintf("%s — %s (prefix + a, %s)", cmd.Name, cmd.Title, cmd.TmuxKeybinding)
		}
		keybindings = append(keybindings, CustomKeybinding{
			Key:             cmd.TmuxKeybinding,
			Command:         cmd.Command,
			Comment:         comment,
			IsMissionScoped: cmd.IsMissionScoped(),
		})
	}
	return keybindings
}

// SourceKeybindings sources the keybindings file into a running tmux server.
// Returns silently if no tmux server is running.
func SourceKeybindings(keybindingsFilepath string) error {
	// Check if tmux server is running
	if err := exec.Command("tmux", "list-sessions").Run(); err != nil {
		return nil
	}

	if err := exec.Command("tmux", "source-file", keybindingsFilepath).Run(); err != nil {
		return stacktrace.Propagate(err, "failed to source keybindings into running tmux server")
	}

	return nil
}
